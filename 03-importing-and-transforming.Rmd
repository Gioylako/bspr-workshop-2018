# Importing and transforming proteomics data

## Importing flat files

## Calculating fold change and enrichment

### Fold change and log-fold change

Fold changes are ratios, the ratio of say protein expression before and
after treatment, where a value larger than 1 for a protein implies that 
protein expression was greater after the treatment.

In life sciences, fold change is often reported as log-fold change. Why is that?
There are at least two reasons which can be shown by plotting.

One is that ratios are not symmetrical around 1, so it's difficult to observe
both changes in the forwards and backwards direcion i.e. proteins where expression
went up and proteins where expression went down due to treatment. When we 
transform ratios on a log scale, the scale becomes symmetric around 0 and thus
we can now observe the distribution of ratios in terms of positive, negative or
no change.

```{r fold-change-1}
set.seed(10)
x <- 2^(rnorm(100))
y <- 2^(rnorm(100))
ratios <- tibble(value = x/y, label = "ratios")
logratios <- tibble(value = log2(ratios$value), label = "logratios")

bind_rows(ratios,logratios) %>% 
  ggplot(aes(value)) +
  geom_histogram(binwidth = 2, colour = "grey50", fill = "white") +
  ggplot2::facet_wrap(~ label) +
  theme_minimal()
```

A second reason is that transforming values onto a log scale changes where
the numbers actually occur when plotted on that scale. If we consider the log
scale to represent magnitudes, then we can more easily see changes of small and
large magnitudes when we plot the data.

For example, a fold change of 32 times can be either a ratio 1/32 or 32/1. 

1/32 is much closer to 1 than 32/1, but transformed to a log scale we see that in 
terms of magnitude of difference it is the same as 32/1.

```{r fold-change-2}
x2 <- 2^seq(1,5)
y_vals <- c(rev(1/x2),1,x2)
names <- c(paste0("1/",rev(x2)),1,x2)
x_vals <- seq(along=y_vals)

dat <- tibble(x_vals,y_vals,names)

p1 <- ggplot(dat,aes(x_vals,y_vals, label = names)) +
  geom_text() +
  geom_hline(yintercept = 1) +
  theme_minimal() +
  labs(x = NULL, y = NULL) +
  scale_x_continuous(breaks = NULL)


p2 <- ggplot(dat,aes(x_vals,y_vals, label = names)) +
  geom_text() +
  geom_hline(yintercept = 1) +
  scale_y_continuous(trans = "log2") +
  theme_minimal() +
  labs(x = NULL, y = NULL) +
  scale_x_continuous(breaks = NULL)

plot_grid(p1,p2)

```

# Fold change and t-test

1. Load the data, we need multiple replicates for each condition. To be tidy
each protein is a set of observations (rows) of the variables, which are the
values recorded for each replicate (columns).

```{r load-data, echo=FALSE, eval=T}
# Emily's sample data set, missing values are NaN and clean up names
dat_em <- read_csv("data/MergedFinalProt_1colPerFile_6files_filtered.csv", 
                   na = "NaN") %>% clean_names()

# Have a look at the dataset
glimpse(dat_em)
```

2. Tidy up and deal with missing values, either impute or exclude missing values
and normalise.

Let's consider our proteomics data as a distribution of values, one value for each
protein in our experiment that together form a distribution. 
If we have replicate experiments we'll therefore have multiple distributions.

A quantile represents a region of distribution, for example the 0.95 quantile
is the value such that 95% of the data lies below it. To normalise two or more
distributions with each other without recourse to a reference distribution we:

(i) Rank (quantile) the value in each experiment (column) from lowest to highest.
(ii) Sort each experiment (column) from lowest to highest value.
(iii) Calculate the mean across the experiments (rows) on the sorted values.
(iv) Substitute the mean values according to rank for each experiment to restore
the original order.

[Dave Tang's Blog : Quantile Normalisation in R](https://davetang.org/muse/2014/07/07/quantile-normalisation-in-r/)

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">.<a href="https://twitter.com/ewanbirney?ref_src=twsrc%5Etfw">@ewanbirney</a> Neither corresponds to the <a href="https://twitter.com/Bioconductor?ref_src=twsrc%5Etfw">@Bioconductor</a> implementation of quantile norm (est 2001 and explained below) <a href="http://t.co/lCyy6YyNB8">pic.twitter.com/lCyy6YyNB8</a></p>&mdash; Rafael Irizarry (@rafalab) <a href="https://twitter.com/rafalab/status/545586012219772928?ref_src=twsrc%5Etfw">December 18, 2014</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


```{r tidy-data}
# Tidy data up
dat_tidy <- dat_em %>%
  # Remove missing values
  drop_na() %>% 
  # Select and rename columns
  select(protein_accession = protein_key_protein_accession,
         protein_description,
         wt1 = protein_ngram_on_column_emilly_bowler_wt_rep1_001_merged_spectrum_ia_final_protein,
         wt2 = protein_ngram_on_column_emilly_bowler_wt_rep2_001_merged_spectrum_ia_final_protein,
         wt3 = protein_ngram_on_column_emilly_bowler_wt_rep3_001_merged_spectrum_ia_final_protein,
         kog1 = protein_ngram_on_column_emilly_bowler_kogsk_rep1_001_merged_spectrum_ia_final_protein,
         kog2 = protein_ngram_on_column_emilly_bowler_kogsk_rep2_merged_ia_final_protein,
         kog3 = protein_ngram_on_column_emilly_bowler_kogsk_rep3_001_merged_spectrum_ia_final_protein)

# Plot data
dat_tidy %>% 
  ggplot(aes(log2(wt1))) + 
  geom_density() +
  geom_density(aes(log2(wt2), colour = "blue")) +
  geom_density(aes(log2(wt3), colour = "red"))
  

# Normalise to maximum column value
dat_norm_max <- dat_tidy %>% 
  mutate(wt1 = wt1/max(wt1),
         wt2 = wt2/max(wt3),
         wt3 = wt3/max(wt3),
         kog1 = kog1 / max(kog1),
         kog2 = kog2 / max(kog2),
         kog3 = kog3 / max(kog3)
         )

# Normalise to median column value
dat_norm_med <- dat_tidy %>% 
  mutate(wt1 = wt1/median(wt1),
         wt2 = wt2/median(wt3),
         wt3 = wt3/median(wt3),
         kog1 = kog1 / median(kog1),
         kog2 = kog2 / median(kog2),
         kog3 = kog3 / median(kog3)
         )

dat_rank <- dat_tidy %>% select(-c(1:2,6:8)) %>% 
  apply(., 2, rank, ties.method="min") %>% as.data.frame()

dat_sort <- dat_tidy %>% select(-c(1:2,6:8)) %>% 
  apply(., 2, sort) %>% as.data.frame()

dat_mean <- dat_sort %>% apply(., 1, mean)

index_mean <- function(my_idx, my_mean){
  return(my_mean[my_idx])
}

dat_norm <- dat_rank %>% 
  apply(.,2,index_mean, my_mean = dat_mean) %>% 
  as.data.frame()

# dat_wt %>% 
#   ggplot(aes(log2(wt1))) + 
#   geom_density() +
#   geom_density(aes(log2(wt2), colour = "blue")) +
#   geom_density(aes(log2(wt3), colour = "red"))

# Quantile normalisation : the aim is to give different distributions the
# same statistical properties
quantile_normalisation <- function(df){
  #
  df_rank <- apply(df,2,rank,ties.method="average")
  df_sorted <- data.frame(apply(df, 2, sort))
  df_mean <- apply(df_sorted, 1, mean)
   
  index_to_mean <- function(my_index, my_mean){
    return(my_mean[my_index])
  }
   
  df_final <- apply(df_rank, 2, index_to_mean, my_mean=df_mean) %>% as.data.frame()
  #rownames(df_final) <- rownames(df)
  return(df_final)
}

dt_wt <- dat_tidy %>% select(-c(1:2,6:8))
dt_kog <- dat_tidy %>% select(-c(1:5))

dt_wt_norm <- quantile_normalisation(dt_wt)
dt_kog_norm <- quantile_normalisation(dt_kog)

dat_norm <- bind_cols(dat_tidy[,1:2],dt_wt_norm,dt_kog_norm)
# Have a look at the median normalised data
glimpse(dat_norm_med)

# Save the median normalised data
write_excel_csv(dat_norm,"data/example_median_nomralised_proteomics_data.csv")

```


```{r impute, eval=FALSE}
# Impute NA with lowest value, need to change this!
control <- dat_select %>% filter(!is.na(control_1) | 
                                   !is.na(control_2) | 
                                   !is.na(control_3)) %>% select(3,4,5) 

treatment <- dat_select %>% filter(!is.na(ras_1) | 
                                   !is.na(ras_2) | 
                                   !is.na(ras_3)) %>% select(6,7,8) 

# Impute minimum
row_min <- function(x) apply(x,1,min,na.rm = TRUE)
impute_min <- function(x) replace(x, is.na(x), row_min(x))

#control_na <- control %>% filter(!complete.cases(.))
impute_min(control)

 
control %>% replace_na(apply(.,1,min))
```

3. Use `t.test` to perform Welch Two Sample t-test on untransformed data. 
This outputs the p-values we need for each protein.


```{r t-test}
# T-test function for multiple experiments
expriments_ttest <- function(dt,grp1,grp2){
  # Subset control group and convert to numeric
  x <- dt[grp1] %>% unlist %>% as.numeric()
  # Subset treatment group and convert to numeric
  y <- dt[grp2] %>% unlist %>% as.numeric()
  # Perform t-test
  result <- t.test(x, y)
  # Return p-values
  return(result$p.value)
}  

# Apply t-test function to data
# array = dat, 1 = rows, FUN = expriments_ttest, and arguements
# For median normalised data
p_vals <- apply(dat_norm,1,expriments_ttest, grp1 = c(3:5), grp2 = c(6:8))
# For maximum normalised data
p_vals_max <- apply(dat_norm_max,1,expriments_ttest, grp1 = c(3:5), grp2 = c(6:8))

# Plot histograms
hist(p_vals)
hist(p_vals_max)
```

4. Perform log transformation of the observations for each protein.

```{r log-data}
# Select columns and log data
dat_log <- dat_norm %>% 
  select(-c(protein_accession,protein_description)) %>% log2()
dat_max_log <- dat_norm_max %>% 
  select(-c(protein_accession,protein_description)) %>% log2()
```

5. Calculate the mean observation for each protein under each condition.

```{r mean-log}
con <- apply(dat_log[,1:3],1,mean)
trt <- apply(dat_log[,4:6],1,mean)

con_max <- apply(dat_max_log[,1:3],1,mean)
trt_max <- apply(dat_max_log[,4:6],1,mean)
```

6. The log fold change is then the difference between condition 1 and condition 2.
Plot a histogram to look at the distribution.

```{r fold-change}
# Calculate fold change
dat_fc <- con - trt
dat_max_fc <- con_max - trt_max

# Plot histograms
hist(dat_fc)
hist(dat_max_fc)
```

7. Create a combined table of log fold change and p-values for all the proteins
for plotting a volcano plot.

```{r vol-pot}
dat <- data.frame(prots= dat_norm$protein_accession,
                      logfc = dat_fc, 
                      pval = -1*log10(p_vals))

dat_max <- data.frame(prots= dat_norm_max$protein_accession,
                      logfc = dat_max_fc, 
                      pval = -1*log10(p_vals_max))

dat_max %>% ggplot(aes(logfc,pval)) + geom_point()

dat %>% ggplot(aes(logfc,pval)) + geom_point()

```
